import React, { useMemo, useState } from 'react'
import { CellProps, useSortBy, useTable } from 'react-table'
import { QuestionCircleOutlined } from '@ant-design/icons'
import { Button, Col, DatePicker, Form, Row, Tooltip } from 'antd'
import clsx from 'clsx'
import { Moment } from 'moment'
import moment, { Moment as MomentTimezone } from 'moment-timezone'

import global_styles from '@/components/admin/css/admin.module.css'
import styles from '@/components/admin/pages/analytics/analytics.module.css'
import { doRequest } from '@/lib/Api'
import flattenInput from '@/lib/flattenInput'
import { PushNotificationsReportType } from '@/model/analyticsModel'
import type { FC } from '@/model/commonModel'

type InitialValues = {
  start: MomentTimezone | string
  end: MomentTimezone | string
}

type TableColumnValues = {
  [key: string]: string | number | JSX.Element
}

const PushNotifications: FC = () => {
  const [isFormLoading, setFormLoading] = useState<boolean>(false)
  const [errors, setErrors] = useState<string[]>([])
  const [reportData, setReportData] = useState<PushNotificationsReportType[]>([])

  const initialFormValues: InitialValues = {
    start: '',
    end: moment().startOf('isoWeek'),
  }

  const disabledDateEnd = (current: Moment) => {
    return current && current.valueOf() >= moment().valueOf()
  }

  const onSubmit = async (values: InitialValues) => {
    const data = values
    if (data['start'] && typeof data['start'] !== 'string') {
      data['start'] = data['start'].format('YYYY-MM-DD HH:mm:00.000+00:00')
    }
    if (data['end'] && typeof data['end'] !== 'string') {
      data['end'] = data['end'].format('YYYY-MM-DD HH:mm:00.000+00:00')
    }

    setFormLoading(true)
    setErrors([])

    const response = await doRequest<PushNotificationsReportType[], PushNotificationsReportType[]>({
      endpoint: process.env.NEXT_PUBLIC_API_POST_ANALYTICS_PUSH_NOTIFICATIONS!,
      method: 'POST',
      data,
    })

    if (response._cc_errors.length) {
      const responseErrors = response._cc_errors.map((error) => (typeof error !== 'string' ? error.text : error))
      setErrors(responseErrors)
    } else {
      setReportData(response.data)
    }

    setFormLoading(false)
  }

  return (
    <>
      <p className={global_styles.h3}>Push notifications</p>

      <Form
        name='push-notifications'
        labelCol={{ span: 4 }}
        wrapperCol={{ span: 16 }}
        labelAlign='left'
        onFinish={onSubmit}
        initialValues={initialFormValues}
      >
        <Form.Item
          label={`Specify start date`}
          name='start'
          extra={
            'From this date the report will be generated. You can leave the field empty and the report will be generated by weeks'
          }
        >
          <DatePicker allowClear={true} format='YYYY-MM-DD HH:mm' showTime={{ format: 'HH:mm' }} />
        </Form.Item>
        <Form.Item
          label={`Specify end date`}
          name='end'
          rules={[
            {
              required: true,
              message: 'Field is required',
            },
          ]}
        >
          <DatePicker
            allowClear={false}
            disabledDate={disabledDateEnd}
            format='YYYY-MM-DD HH:mm'
            showTime={{ format: 'HH:mm' }}
          />
        </Form.Item>

        <Form.Item wrapperCol={{ span: 19 }} className={global_styles['mt-1']}>
          <Row>
            <Col span={16}>
              <Button type='primary' htmlType='submit' loading={isFormLoading}>
                Create a report
              </Button>
            </Col>
          </Row>
          {errors.length > 0 && (
            <Row className={global_styles.error_text} dangerouslySetInnerHTML={{ __html: errors.join('<br />') }} />
          )}
        </Form.Item>
      </Form>

      {Object.keys(reportData).length > 0 && (
        <div className={clsx(global_styles.mt_1)}>
          <p>
            If notifications are still &quot;processed&quot;, it means that push sender has lost them.
            <br />
            Some notifications can be sent, but because of timeout api error they &quot;didn&apos;t&quot; change their
            status from processed to &quot;sent&quot;.
          </p>
          <Table data={reportData} />
        </div>
      )}
    </>
  )
}

type TableColumns = Array<{
  Header: string | JSX.Element
  accessor: string
  Cell?: (props: CellProps<TableColumnValues, number>) => JSX.Element
  className?: string
  columns?: TableColumns
  disableSortBy?: boolean
  sortDescFirst?: boolean
}>

const Table: FC<{ data: PushNotificationsReportType[] }> = ({ data }) => {
  const getColumns = useMemo(
    () => () => {
      const columns: TableColumns = [
        {
          Header: '',
          accessor: 'name',
          disableSortBy: true,
        },
      ]
      data.forEach((row, index) => {
        columns.push({
          Header: `${row.date[0]} ‚Äì ${row.date[1]}`,
          accessor: `date${index}`,
          disableSortBy: true,
          columns: [
            {
              Header: 'Sent',
              accessor: `send${index}`,
              className: styles.bordered_left,
            },
            {
              Header: 'Opened',
              accessor: `opened${index}`,
            },
            {
              Header: 'Error',
              accessor: `error${index}`,
            },
            {
              Header: 'Processed',
              accessor: `processed${index}`,
            },
          ],
        })
      })
      return columns
    },
    [data],
  )

  const columns = React.useMemo(() => getColumns(), [getColumns])

  // eslint-disable-next-line react-hooks/exhaustive-deps
  const tableData = React.useMemo(() => getTableData(data), flattenInput(data))

  const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } = useTable(
    {
      columns,
      data: tableData,
    },
    useSortBy,
  )

  return (
    <>
      <table className={styles.table} {...getTableProps()}>
        <thead>
          {/*@ts-ignore*/}
          {headerGroups.map((headerGroup) => (
            // eslint-disable-next-line react/jsx-key
            <tr {...headerGroup.getHeaderGroupProps()}>
              {/*@ts-ignore*/}
              {headerGroup.headers.map((column) => (
                // eslint-disable-next-line react/jsx-key
                <th
                  // @ts-ignore
                  {...column.getHeaderProps(column.getSortByToggleProps())}
                  // @ts-ignore
                  title={column.canSort ? 'Sort the column' : ''}
                  className={clsx(
                    // @ts-ignore
                    column.parent?.className || column.className,
                    // @ts-ignore
                    column.canSort ? styles.sortable : undefined,
                  )}
                >
                  {column.render('Header')}
                  <span className={styles.sort_icon}>
                    {/*@ts-ignore*/}
                    {column.isSorted
                      ? // @ts-ignore
                        column.isSortedDesc
                        ? ' ‚ñº'
                        : ' ‚ñ≤'
                      : ''}
                  </span>
                </th>
              ))}
            </tr>
          ))}
        </thead>
        <tbody {...getTableBodyProps()}>
          {rows.map((row) => {
            prepareRow(row)
            return (
              // eslint-disable-next-line react/jsx-key
              <tr {...row.getRowProps()} className={row.id === '0' ? global_styles.bold : undefined}>
                {row.cells.map((cell) => {
                  return (
                    // eslint-disable-next-line react/jsx-key
                    <td
                      {...cell.getCellProps()}
                      // @ts-ignore
                      className={clsx(cell.column?.className)}
                    >
                      {cell.render('Cell')}
                    </td>
                  )
                })}
              </tr>
            )
          })}
        </tbody>
      </table>
    </>
  )
}

const getTableData = (apiReportResult: PushNotificationsReportType[]) => {
  const data: {
    [key: string]: {
      [key: string]: number | JSX.Element
    }
  } = {}

  const total: { [key: string]: number | string } = {
    name: 'TOTAL',
  }
  apiReportResult.forEach((table, index) => {
    table.rows.forEach((row) => {
      const type = row.specific_key === null ? `${row.type} (null)` : row.specific_key
      let message = row.message

      if (message.includes('notifications.')) {
        switch (message) {
          case 'notifications.event_schedule_starts_24_hours':
          case 'notifications.event_schedule_starts_1_hour':
            message = 'Don\'t miss out on "%eventName%" on %time%'
            break
          case 'notifications.club_registered_as_co_host':
            message = '%displayName% added you as a moderator of "%eventName%" hosted by %clubTitle% on %time%'
            break
          case 'notifications.event_schedule_subscription':
            message = 'Tap to listen üëâ ‚Äú%meetingName%‚Äù'
            break
          case 'notifications.followed_user_mutual_club':
            message = '%speakers% about ‚Äú%meetingName%‚Äù by ‚Äú%clubTitle%‚Äù right now. Tap to listen üëâ'
            break
          case 'notifications.let_you_in':
            message = 'üó£ %displayName% let you in'
            break
          case 'notifications.registered_as_speaker':
            message = '%displayName% added you as a speaker of "%eventName%" on %time%'
            break
        }
      }
      if (!data[type]) {
        data[type] = {
          name: (
            <>
              {type}
              <Tooltip title={message}>
                <QuestionCircleOutlined
                  style={{
                    marginLeft: '5px',
                    verticalAlign: 'middle',
                  }}
                />
              </Tooltip>
            </>
          ),
        }
      }
      if (!total[`${row.status}${index}`]) {
        total[`${row.status}${index}`] = 0
      }
      data[type][`${row.status}${index}`] = row.count
      ;(total[`${row.status}${index}`] as number) += row.count
    })
  })

  return [total, ...Object.values(data)]
}

export default PushNotifications
